#pragma once

const char *VSString =
"#version 400 core\n"
"\n"
"layout(location = 0) in vec3 position;\n"
"\n"
"void main()\n"
"{\n"
"\tgl_Position = vec4(position, 1.0);\n"
"}";

const char *FSString =
"#version 400 core\n"
"\n"
"uniform vec2 iResolution;\n"
"uniform float iGlobalTime;\n"
"uniform vec3 iCamPos;\n"
"uniform vec3 iCamTarget;\n"
"\n"
"in vec4 gl_FragCoord;\n"
"\n"
"out vec4 fColor;\n"
"\n"
"vec2 map (vec3 p, int octaves);\n"
"#define FLT_EQ(a, b) (abs(a - b) < 0.1)\n"
"\n"
"float noise(vec2 p) \n"
"{\n"
"\tvec2 f = fract(p);\n"
"\tp = floor(p);\n"
"\tfloat v = p.x+p.y*1000.0;\n"
"\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n"
"\tr = fract(100000.0*sin(r*.001));\n"
"\tf = f*f*(3.0-2.0*f);\n"
"\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n"
"}\n"
"\n"
"vec3 getNormal(vec3 p, int octaves)\n"
"{\n"
"\tfloat h = 0.002;\n"
"\tvec3 n;\n"
"\tn.x = map(p + vec3(h, 0, 0), octaves).x - map(p - vec3(h, 0, 0), octaves).x;\n"
"\t//n.y = map(p + vec3(0, h, 0), octaves).x - map(p - vec3(0, h, 0), octaves).x;\n"
"\tn.y = 2*h;\n"
"\tn.z = map(p + vec3(0, 0, h), octaves).x - map(p - vec3(0, 0, h), octaves).x;\n"
"    return normalize(n);\n"
"}\n"
"\n"
"float fbm(vec2 p, int octaves) \n"
"{\t\n"
"\tfloat value = 0.0; \n"
"\tfloat amplitude = 0.5; \n"
"\tfloat frequency = 0.4; \n"
"\n"
"\t// Terrain distortion\n"
"\tfloat tmpW = (noise(p*0.05)*0.3 + 0.5);\n"
"\ttmpW = 10*tmpW *tmpW*tmpW*tmpW*tmpW;\n"
"\tvalue += tmpW * noise(0.1*p);\n"
"\n"
"\tfor (int i = 0; i < 12; i++) \n"
"\t{\n"
"\t\tif (i < octaves) \n"
"\t\t{\n"
"\t\t\tvalue += -amplitude * noise(0.8*p*frequency);\n"
"\t\t}\n"
"\t\telse break;\n"
"\n"
"\t\tamplitude *= 0.5;\n"
"\t\tfrequency *= 2.0;\n"
"\t}\n"
"\treturn value;\n"
"}\n"
"\n"
"#define SKY_MAT -1.0\n"
"#define TERRAIN_MAT 0.0\n"
"#define WATER_MAT 1.0\n"
"#define MAX_T 28.0\n"
"#define MAX_STEPS 100\n"
"\n"
"#define WATER_LINE -0.3\n"
"#define GROUND_LINE 0.0\n"
"#define CLOUD_LINE 10.0\n"
"\n"
"vec2 map(vec3 p, int octaves)\n"
"{\n"
"\tfloat tMin = MAX_T; // nearest terrain intersection\n"
"\tfloat material = SKY_MAT;\n"
"\n"
"\tfloat h = fbm(p.xz, octaves);\n"
"\th += 1.5*smoothstep(-0.0, 1.2, h);\n"
"\tfloat depth = p.y - h;\n"
"\tif (depth < tMin)\n"
"    { \n"
"\t\ttMin = depth;\n"
"\t\tmaterial = TERRAIN_MAT;\n"
"\t}\n"
"\n"
"\treturn vec2(tMin, material);\n"
"}\n"
"\n"
"vec2 castRay(vec3 ro, vec3 rd, int octaves)\n"
"{\n"
"\tfloat t = 0.0; \n"
"\tfloat material = SKY_MAT;\n"
"\tfloat prec = 0.002;\n"
"\n"
"\tfor (int i = 0; i < MAX_STEPS; ++i) \n"
"    {\n"
"\t\tvec2 res = map(ro + rd*t, octaves);\n"
"\t\tfloat stepSize = 0.4*res.x;\n"
"\t\tt += stepSize;\n"
"\n"
"\t\tif (stepSize < prec || t > MAX_T)\n"
"\t\t{\n"
"\t\t\tbreak;\n"
"\t\t}\n"
"\t\telse\n"
"\t\t{\n"
"\t\t\tmaterial = res.y;\n"
"\t\t}\n"
"\t}\n"
"\n"
"\tif (t > MAX_T) \n"
"\t\tmaterial = SKY_MAT;\n"
"\n"
"\treturn vec2(t, material);\n"
"}\n"
"\n"
"float calcShadow(vec3 ro, vec3 rd, int octaves)\n"
"{\n"
"\tfloat k = 2.0;\n"
"\tfloat precis = 0.02;\n"
"\tfloat minT = 0.2;\n"
"\tfloat tMax = 1.0;\n"
"\tfloat t = minT;\n"
"\tfloat shadow = 1.0;\n"
"\n"
"\tfor (int i = 0; i < 6; ++i)\n"
"\t{\n"
"\t\tfloat stepSize = 1.0*map(ro + rd*t, octaves).x;\n"
"\n"
"\t\tif (stepSize < precis)\n"
"\t\t{\n"
"\t\t\tshadow = 0.0;\n"
"\t\t\tbreak;\n"
"\t\t}\n"
"\t\tif (t > tMax)\n"
"\t\t{\n"
"\t\t\tbreak;\n"
"\t\t}\n"
"\t\tshadow = min(shadow, k * stepSize / t);\n"
"\t\tt += stepSize;\n"
"\t}\n"
"\tshadow = clamp(shadow, 0.3, 1.0);\n"
"\treturn shadow;\n"
"}\n"
"\n"
"vec3 sunPosition = normalize(vec3(0, 0.5, -1));\n"
"vec3 skyColor = vec3(.5,.6,0.8)*0.5;\n"
"vec3 sunColor = vec3(1.0, 0.9, 0.3);\n"
"\n"
"vec3 sky(vec3 rayDirection)\n"
"{\n"
"\t// Sun orb\n"
"\tfloat sunDot = max(dot(rayDirection, sunPosition), 0.0);\n"
"\treturn skyColor + pow(sunDot, 80.0) * sunColor;\n"
"}\n"
"\n"
"vec3 clouds(vec3 color, vec3 rayOrigin, vec3 rayDirection)\n"
"{\n"
"\tif (rayDirection.y < 0.01) \n"
"\t\treturn color;\n"
"\n"
"\tvec3 skyPoint = rayOrigin + rayDirection * ((CLOUD_LINE - rayOrigin.y)/rayDirection.y);\n"
"\tskyPoint -= -iGlobalTime*0.75;\n"
"\tfloat fbmFactor = 0.3 + fbm(skyPoint.xz, 4);\n"
"\n"
"\t// Lerp between sky current(sky) color and cloud color\n"
"\tvec3 cloudColor = vec3(0.9, 0.9, 0.9);\t\t\t\t\t\t\t\t\n"
"\tcolor = mix(color, cloudColor, clamp(fbmFactor*rayDirection.y, 0.0, 1.0));\t// Horizon fade\n"
"\treturn color;\n"
"}\n"
"\n"
"vec3 render (vec3 ro, vec3 rd)\n"
"{\n"
"\tconst int geoLOD = 4;\t\t// fBm octaves for ray marching test\n"
"\tconst int normalLOD = 11;\t// fBm octaves for lighting\n"
"\t\n"
"\tvec2 result = castRay(ro, rd, geoLOD);\n"
"\tvec3 color;\n"
"\t\n"
"\tfloat travelledDistance = result.x;\n"
"\tfloat material = result.y;\n"
"\tvec3 point = ro + rd*travelledDistance;\n"
"\n"
"\t// Sky color\n"
"\tif (FLT_EQ(material, SKY_MAT))\n"
"\t{\n"
"\t\tcolor = clouds(sky(rd), ro, rd); \n"
"\t\treturn color;\n"
"\t}\n"
"\n"
"\t// Level of detail\n"
"\tint LOD = normalLOD;\n"
"\tint LODline = 0;\n"
"\tif (travelledDistance > LODline)\n"
"\t{\n"
"\t\tfloat t = (travelledDistance - LODline) / (MAX_T - LODline);\n"
"\t\tLOD = int(mix(normalLOD, geoLOD + 2, t));\n"
"\t}\n"
"\tvec3 normal = getNormal(point, LOD);\n"
"\n"
"\tif (FLT_EQ(material, TERRAIN_MAT))\n"
"\t{\n"
"\t\tcolor = vec3(254/255.0, 244/255.0, 181.0/255.0);\t// Sand color\n"
"\t\tfloat t;\n"
"\n"
"\t\tvec3 groundColor = vec3(127/255.0, 113/255.0, 73.0/255.0);\n"
"\t\tt = (point.y - (WATER_LINE)) * 6; \n"
"\t\tt = clamp(t, 0, 1);\n"
"\t\tcolor = mix(color, groundColor, t);\n"
"\n"
"\t\tvec3 hillColor =  vec3(207/255.0, 198/255.0, 194.0/255.0);\n"
"\t\tt = (point.y - (GROUND_LINE)) * 0.9;\n"
"\t\tt = clamp(t, 0, 1);\n"
"\t\tcolor = mix(color, hillColor, t);\n"
"\n"
"\t\tif (point.y < 0.5 && point.y > WATER_LINE)\t// Low grass\n"
"\t\t{\n"
"\t\t\tif (normal.y > 0.8)\n"
"\t\t\t{\n"
"\t\t\t\tcolor = vec3(140/255.0,0.7, 36.0/255.0)*0.7;\n"
"\t\t\t}\n"
"\t\t}\n"
"\t\telse if (point.y > 0.5)\t// High grass\n"
"\t\t{\n"
"\t\t\tif (normal.y > 0.9)\n"
"\t\t\t{\n"
"\t\t\t\tcolor = vec3(140/255.0,0.7, 36.0/255.0)*1.2;\n"
"\t\t\t}\n"
"\t\t}\n"
"\t\telse if (point.y < WATER_LINE)\t// Water moss\n"
"\t\t{\n"
"\t\t\tif (normal.y > 0.95)\n"
"\t\t\t{\n"
"\t\t\t\tcolor = vec3(108/255.0, 80/255.0, 7.0/255.0);\n"
"\t\t\t}\n"
"\t\t}\n"
"\t}\n"
"\n"
"\t// Lambert model\n"
"\tfloat ambient = 0.2;\n"
"\tfloat diffuse = max(dot(normal, sunPosition), 0.0);\n"
"\tfloat shadow = calcShadow(point, sunPosition, geoLOD);\n"
"\tcolor = color * (ambient + diffuse)*shadow;\n"
"\n"
"\t// Water\n"
"\tif (point.y < WATER_LINE)\n"
"\t{\n"
"\t\t//Underwater darkening\n"
"\t\tfloat t = 1 - (WATER_LINE + 0.2 - point.y);\n"
"\t\tt = clamp(t, 0.5, 1.0);\n"
"\t\tcolor *= t;\n"
"\n"
"\t\t// Normal distortion\n"
"\t\tvec3 waterPoint = ro + ((WATER_LINE - ro.y) / rd.y)*rd;\n"
"\t\tfloat time = iGlobalTime*2.9;\n"
"\t\tfloat nx = 0.2*cos(waterPoint.x*20);\n"
"\t\tfloat nz = 0.2*sin(waterPoint.z*20);\n"
"\t\tnx *= noise(waterPoint.xz*20 + time);\n"
"\t\tnz *= noise(waterPoint.xz*20 + time);\n"
"\t\tnormal = normalize(vec3(nx, 7 , nz));\n"
"\n"
"\t\t// Reflection vector\n"
"\t\tvec3 reflectVector = normalize(reflect(rd, normal));\n"
"\t\tvec3 reflectedColor = clouds(sky(reflectVector)*vec3(0.5,0.6,0.8)*0.5, ro, reflectVector);\n"
"\t\t\n"
"\t\t// Refractive factor\n"
"\t\tfloat refractiveFactor = abs(dot(rd, normal));\n"
"\t\trefractiveFactor = pow(refractiveFactor, 2.5);\n"
"\n"
"\t\t// Lerp between reflective and refractive color\n"
"\t\tvec3 oldColor = color;\n"
"\t\tfloat mixFactor = clamp((waterPoint.y - point.y)*1.5, 0.0, 1.0);\n"
"\t\tcolor = mix(reflectedColor, color, refractiveFactor);\t\t// Fresnel\n"
"\t\tcolor = mix(oldColor, color, mixFactor);\n"
"\t}\n"
"\t\n"
"\t// Exponential fog\n"
"\tfloat fog = exp(0.030 * (travelledDistance - 5)) - 1;\n"
"\tfog = clamp(fog, 0, 1);\t\n"
"\tcolor = mix(color, skyColor, fog);\n"
"\treturn color;\n"
"}\n"
"\n"
"vec3 camPath( float time )\n"
"{\n"
"\treturn 850 * vec3(cos(0.2*time), 0.0, cos(0.31*time) );\n"
"}\n"
"\n"
"void main()\t\n"
"{\n"
"\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n"
"    uv = uv * 2.0 - 1.0;\n"
"    uv.x *= iResolution.x / iResolution.y;\n"
"\n"
"\tfloat t = 0.0152*iGlobalTime;\n"
"\n"
"\t//vec3 camPos = camPath(t);\n"
"\t//vec3 camTarget = camPath(t + 0.3);\n"
"\t////camPos.y = fbm(camPos.xz, 4) + 2.5;\n"
"\t//camPos.y = max(fbm(camPos.xz, 4) + 3.0, 3.5);\n"
"\t//camTarget.y = camPos.y - 30;\n"
"\n"
"\tvec3 camPos = iCamPos;\n"
"\tvec3 camTarget = iCamTarget;\n"
"\n"
"\t// camera matrix\n"
"\tvec3 ww = normalize(camTarget-camPos);\n"
"\tvec3 up = (vec3(0.0, 1.0, 0.0));\t\t\t\t\t\t// world up\n"
"\tvec3 uu = normalize(cross(ww, up));\t\t\t\t\t\t// camera right\n"
"\tvec3 vv = normalize(cross(uu, ww));\t\t\t\t\t\t// camera up\n"
"\n"
"\tvec3 ro = camPos;\n"
"\tvec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n"
"\tvec3 color = render(ro, rd);\n"
"\tfColor = vec4(color, 1.0);\n"
"}";